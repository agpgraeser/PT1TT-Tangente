<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>PTn-Parameter Tool</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <style>
        body {
            margin: 0;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            background: #f5f5f5;
        }

        .app-container {
            display: grid;
            grid-template-columns: 1fr 2fr;
            height: 100vh;
        }

        .left-panel {
            background: #ffffff;
            padding: 16px 20px;
            box-shadow: 2px 0 4px rgba(0,0,0,0.05);
            overflow-y: auto;
        }

        .right-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 10px;
            background: #fafafa;
            overflow: hidden;
        }

        #plotArea {
            flex: 1;
            width: 100%;
            height: 100%;
        }

        .panel-title {
            font-weight: 600;
            margin-bottom: 8px;
        }

        .section {
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e0e0e0;
        }

        .left-panel .field-row-compact {
            display: grid;
            grid-template-columns: auto 80px auto 80px auto 80px;
            column-gap: 4px;
            row-gap: 4px;
            align-items: center;
            margin-bottom: 8px;
        }

        .left-panel .field-row-single {
            display: grid;
            grid-template-columns: auto 80px;
            column-gap: 4px;
            align-items: center;
            margin-bottom: 8px;
        }

        .left-panel .field-row-compact label,
        .left-panel .field-row-single label {
            font-size: 0.85rem;
            font-weight: 500;
            text-align: left;
            white-space: nowrap;
        }

        .left-panel .field-row-compact input,
        .left-panel .field-row-single input {
            width: 80px;
            padding: 4px 6px;
            font-size: 0.85rem;
            border-radius: 3px;
            border: 1px solid #ccc;
            text-align: right;
            box-sizing: border-box;
        }

        .left-panel input.output {
            background: #e5f7e5;
            border: 1px solid #b2d8b2;
        }

        .invalid {
            background: #ffcccc !important;
            border-color: #ff4444 !important;
        }
    
        .field-row-compact label {
            display: inline-block;
            width: 60px; /* anpassen nach Bedarf */
        }

        .file-info {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            background-color: #eee;
            color: #333;
            font-size: 0.8rem;
            margin-left: 8px;
        }
        .file-info.loaded {
            background-color: #4CAF50; /* Gr√ºn */
            color: white;
            font-weight: bold;
        }

        

    </style>
</head>

<body>

<div class="app-container">

    <!-- Linkes Drittel -->
    <div class="left-panel">

        <!-- PT1TT-Parameter -->
        <div class="section">
            <div class="panel-title">PT1TT-Parameter mit Wendetangente ermitteln</div>

            <div class="field-row-compact">
                <label for="XA">XA</label>
                <input type="number" id="XA" value="0.00" step="0.01">
                <label for="XE">XE</label>
                <input type="number" id="XE" value="1.00" step="0.01">
                <label for="DX">DX</label>
                <input type="number" id="DX" class="output" value="1.00" readonly>
            </div>

            <div class="field-row-compact">
                <label for="YA">YA</label>
                <input type="number" id="YA" value="0.00" step="0.01">

                <label for="YE">YE</label>
                <input type="number" id="YE" value="1.00" step="0.01">

                <label for="DY">DY</label>
                <input type="number" id="DY" class="output" value="1.00" readonly>
            </div>

            <div class="field-row-single">
                <label for="t0">t‚ÇÄ</label>
                <input type="number" id="t0" value="-100.0" step="0.1">
            </div>
        </div>

        
        <!-- Wendetangenten Methode -->
        <div class="section">
            <div class="panel-title">Wendetangenten Methode f√ºr Mehrspeichersysteme</div>

            <div class="field-row-compact">
                <label for="X1">X1 </label>
                <input type="number" id="X1" value="0.00" step="0.01">

                <label for="t1">t1 </label>
                <input type="number" id="t1" value="0.00" step="0.01">
            </div>

            <div class="field-row-compact">
                <label for="XWP">XWP</label>
                <input type="number" id="XWP" value="0.00" step="0.01">

                <label for="tWP">tWP</label>
                <input type="number" id="tWP" value="0.00" step="0.01">
            </div>

            <div class="field-row-compact">
                <label for="X2">X2</label>
                <input type="number" id="X2" value="0.00" step="0.01">

                <label for="t2">t2</label>
                <input type="number" id="t2" value="0.00" step="0.01">
            </div>
        </div>

        <!-- Kennwerte -->
        <div class="section">
            <div class="panel-title">Kennwerte, K√ºpfm√ºller (TT, TG) & K√ºpfm√ºller korr.(TT1,TG1)</div>

            <div class="field-row-compact">
                <label for="kS">kS</label>
                <input type="number" id="kS" class="output" readonly>

                <label for="TT">TT</label>
                <input type="number" id="TT" class="output" readonly>

                <label for="TG">TG</label>
                <input type="number" id="TG" class="output" readonly>

                <label for="kS1">kS1</label>
                <input type="number" id="kS1" class="output" readonly>

                <label for="TT1">TT1</label>
                <input type="number" id="TT1" class="output" readonly>

                <label for="TG1">TG1</label>
                <input type="number" id="TG1" class="output" readonly>
            </div>
        </div>
        <!-- Upload-Bereich -->
        <div class="section" id="excel-section">
            <div class="panel-title">Messdaten laden</div>

            <div style="display:flex; align-items:center; gap:10px; margin-top:6px;">
                <input type="file" id="excelFile" accept=".xlsx,.xls">
                <div id="fileInfo" 
                     style="padding:3px 8px; border-radius:4px; background:#eee; color:#333; font-size:0.8rem;">
                    Keine Datei
                </div>
            </div>
        </div>
    <div class="field-row-single">
        <label for="showDiff">Abweichungen anzeigen</label>
        <input type="checkbox" id="showDiff">
    </div>
   
        <!-- Weitere Einstellungen -->
        <div class="section">
            <div class="panel-title">Weitere Einstellungen (Platzhalter)</div>
            <div id="excelPreview" style="font-size:0.85rem; color:#333; margin-top:8px;"></div>
        </div>

    </div> <!-- Ende left-panel -->

    <!-- Rechtes Zweidrittel -->
    <div class="right-panel">
        <div id="plotArea" style="width:100%; height:100%;"></div>
    </div>

</div>



<!-- ========================= -->
<!-- 1) Externe Bibliotheken -->
<!-- ========================= -->
<script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>

<script>
console.log("JS geladen");
/* ---------------------------------------------------------
   Globale Variablen
--------------------------------------------------------- */
let loadedFilename = "";


/* ---------------------------------------------------------
   DOM-Referenzen
--------------------------------------------------------- */
const XA = document.getElementById("XA");
const XE = document.getElementById("XE");
const DX = document.getElementById("DX");

const YA = document.getElementById("YA");
const YE = document.getElementById("YE");
const DY = document.getElementById("DY");


const t0  = document.getElementById("t0");
const t1 = document.getElementById("t1");
const tWP = document.getElementById("tWP");
const t2 = document.getElementById("t2");

const X1 = document.getElementById("X1");
const XWP = document.getElementById("XWP");
const X2 = document.getElementById("X2");

const kS  = document.getElementById("kS");
const TT  = document.getElementById("TT");
const TG  = document.getElementById("TG");

const kS1 = document.getElementById("kS1");
const TT1 = document.getElementById("TT1");
const TG1 = document.getElementById("TG1");

const excelInput = document.getElementById("excelFile");
const fileInfo   = document.getElementById("fileInfo");

excelInput.addEventListener("change", handleExcelFile);


/* ---------------------------------------------------------
   Datencontainer f√ºr Excel
--------------------------------------------------------- */
let timeData = [];
let xData = [];
let yData = [];
let systemName = "";
let varNames = {};
let units = {};
let fileName = "";

/* ---------------------------------------------------------
   Hilfsfunktionen
--------------------------------------------------------- */
function isValidNumber(el) {
    if (!el) return false;
    const v = parseFloat(el.value);
    return !(isNaN(v) || !isFinite(v));
}

function updateFieldStyle(el) {
    if (!el) return;
    if (isValidNumber(el)) el.classList.remove("invalid");
    else el.classList.add("invalid");
}

/* ---------------------------------------------------------
   DX = XE - XA
--------------------------------------------------------- */
function updateDX() {
    updateFieldStyle(XA);
    updateFieldStyle(XE);

    if (isValidNumber(XA) && isValidNumber(XE)) {
        const xa = parseFloat(XA.value);
        const xe = parseFloat(XE.value);
        DX.value = (xe - xa).toFixed(2);
        //updateXvalues();//
    } else {
        DX.value = "";
        X1.value = "";
        XWP.value = "";
        X2.value = "";
    }

    updateDerivedValues();
}

/* ---------------------------------------------------------
   DY = YE - YA
--------------------------------------------------------- */
function updateDY() {
    updateFieldStyle(YA);
    updateFieldStyle(YE);

    if (isValidNumber(YA) && isValidNumber(YE)) {
        const ya = parseFloat(YA.value);
        const ye = parseFloat(YE.value);
        DY.value = (ye - ya).toFixed(2);
    } else {
        DY.value = "";
    }

    updateDerivedValues();
}

function allInputsReady() {
    return (
        XA.value !== "" &&
        XE.value !== "" &&
        YA.value !== "" &&
        YE.value !== "" &&
        tWP.value !== "" &&
        XWP.value !== ""
    );
}


/* ---------------------------------------------------------
   X10/X50/X90 berechnen
--------------------------------------------------------- */
function updateXvalues() {
    if (!isValidNumber(XA) || !isValidNumber(DX)) {
        X1.value = "";
        XWP.value = "";
        X2.value = "";
        return;
    }

    const xa = parseFloat(XA.value);
    const dx = parseFloat(DX.value);

    /*X10.value = (xa + 0.1 * dx).toFixed(2);
    X50.value = (xa + 0.5 * dx).toFixed(2);
    X90.value = (xa + 0.9 * dx).toFixed(2);*/
}

/* ---------------------------------------------------------
   Zeitvalidierung
--------------------------------------------------------- */
function updateTimeOrder() {
    updateFieldStyle(t0);
    updateFieldStyle(t1);
    updateFieldStyle(tWP);
    updateFieldStyle(t2);

    if (!isValidNumber(t0) || !isValidNumber(t1) || !isValidNumber(tWP) || !isValidNumber(t2))
        return;

    const t0v  = parseFloat(t0.value);
    const t1v = parseFloat(t1.value);
    const tWPv = parseFloat(tWP.value);
    const t2v = parseFloat(t2.value);

    // üî¥ Pr√ºfung: t0 >= 0
    if (t0v < 0) {
        t0.classList.add("invalid");
    }

    // üî¥ Pr√ºfung: t1 > t0
    if (t1v <= t0v) t1.classList.add("invalid");

    // üî¥ Pr√ºfung: tWP > t0
    if (tWPv <= t0v) tWP.classList.add("invalid");

    // üî¥ Pr√ºfung: t2 > t0
    if (t2v <= t0v) t2.classList.add("invalid");

    // üî¥ Pr√ºfung: t1 < tWP
    if (!(t1v < tWPv)) {
        t1.classList.add("invalid");
        tWP.classList.add("invalid");
    }

    // üî¥ Pr√ºfung: tWP < t2
    if (!(tWPv < t2v)) {
        tWP.classList.add("invalid");
        t2.classList.add("invalid");
    }

    updateDerivedValues();
}
/* ---------------------------------------------------------
   XWP-Bereichspr√ºfung
--------------------------------------------------------- */
function updateXWPRange() {
    // Erst normale Zahlenvalidierung anwenden
    updateFieldStyle(X1);
    updateFieldStyle(XWP);
    updateFieldStyle(X2);

    // Wenn eine Zahl ung√ºltig ist ‚Üí keine Bereichspr√ºfung
    if (!isValidNumber(X1) || !isValidNumber(XWP) || !isValidNumber(X2))
        return;

    const x1  = parseFloat(X1.value);
    const xwp = parseFloat(XWP.value);
    const x2  = parseFloat(X2.value);

    // Bereichspr√ºfung: X1 ‚â§ XWP ‚â§ X2
    if (xwp < x1 || xwp > x2) {
        XWP.classList.add("invalid");
    }
}


/* ---------------------------------------------------------
   Relative Zeiten + kS, TT, TG
--------------------------------------------------------- */
function updateDerivedValues() {
   if(!allInputsReady()) {
    //Ergebnisse zur√ºcksetzen
        kS.value = ""; 
        kS1.value = ""; 
        TT.value = ""; 
        TT1.value = ""; 
        TG.value = ""; TG1.value = "";
        return; 
        // Berechnung abbrechen
};



    const t0v  = parseFloat(t0.value);
    const t1v = parseFloat(t1.value);
    const tWPv = parseFloat(tWP.value);
    const t2v = parseFloat(t2.value);

    const t1_rel = t1v - t0v;
    const tWP_rel = tWPv - t0v;
    const t2_rel = t2v - t0v;

    if (isValidNumber(DX) && isValidNumber(DY) && parseFloat(DY.value) !== 0) {
        kS.value = (parseFloat(DX.value) / parseFloat(DY.value)).toFixed(4);
        kS1.value = (parseFloat(DX.value) / parseFloat(DY.value)).toFixed(4);
    } else {
        kS.value = "";
        kS1.value = "";
    }


    TT.value = t1_rel.toFixed(2); ;
    TT1.value = t1_rel.toFixed(2); ;
    const tt = parseFloat(TT.value);
    const tt1 = parseFloat(TT1.value);
    const t1_corr = (t1_rel - tt).toFixed(2);

    const tWP_corr = (tWP_rel - tt).toFixed(2);
    const t2_corr = (t2_rel - tt).toFixed(2);
    TG.value = (parseFloat(t2_corr) - parseFloat(t1_corr)).toFixed(2);
    TG1.value = (parseFloat(t2_corr) - parseFloat(tWP_corr)).toFixed(2);
}

/* ---------------------------------------------------------
   Modellantwort (PT1TT)
--------------------------------------------------------- */
function computeModelResponse() {
    const XM = [];

    const xa = parseFloat(XA.value);
    const dy = parseFloat(DY.value);
    const ks = parseFloat(kS.value);
    const tt = parseFloat(TT.value);
    const tg = parseFloat(TG.value);
    const t0v = parseFloat(t0.value);

    const tDelay = t0v + tt;

    for (let i = 0; i < timeData.length; i++) {
        const t = timeData[i];

        if (t <= tDelay) {
            XM.push(xa);
        } else {
            const exponent = -(t - tDelay) / tg;
            XM.push(xa + ks * dy * (1 - Math.exp(exponent)));
        }
    }

    return XM;
}
/* ---------------------------------------------------------
   Modellantwort 2 (PT1TT) mit kS1, TT1, TG1
--------------------------------------------------------- */
function computeModelResponse2() {
    const XM2 = [];

    const xa = parseFloat(XA.value);
    const dy = parseFloat(DY.value);
    const ks1 = parseFloat(kS1.value);
    const tt1 = parseFloat(TT1.value);
    const tg1 = parseFloat(TG1.value);
    const t0v = parseFloat(t0.value);

    const tDelay = t0v + tt1;

    for (let i = 0; i < timeData.length; i++) {
        const t = timeData[i];

        if (t <= tDelay) {
            XM2.push(xa);
        } else {
            const exponent = -(t - tDelay) / tg1;
            XM2.push(xa + ks1 * dy * (1 - Math.exp(exponent)));
        }
    }

    return XM2;
}
function computeDifferences() {
    if (!excelTime || !excelY || excelTime.length === 0) return [];

    const diffs = [];

    for (let i = 0; i < excelTime.length; i++) {
        const t = excelTime[i];
        const yExcel = excelY[i];
        const yModel = modelFunction(t);   // deine Modellfunktion

        diffs.push(yExcel - yModel);
    }

    return diffs;
}
function computeSquaredDifferences(meas, model) {
    
    if (!excelTime || !excelY || excelTime.length === 0) return [];
    const diffs = [];
    const n = Math.min(meas.length, model.length);
    for (let i = 0; i < n; i++) {
        const d = meas[i] - model[i];
        diffs.push(d * d);
    }
    return diffs;
}


/* ---------------------------------------------------------
   Excel einlesen
--------------------------------------------------------- */
 


function handleExcelFile(event) {
    const file = event.target.files[0];
    if (!file) return;

    // Reset (optional)
    fileInfo.innerText = "Lade...";
    fileInfo.classList.remove("loaded");

    fileName = file.name.replace(/\.[^/.]+$/, "");
    loadedFilename = file.name;

    const reader = new FileReader();
    reader.onload = function(e) {
// ---------------------------------------------------------
// Ergebnisse zur√ºcksetzen beim Laden einer neuen Excel-Datei
// ---------------------------------------------------------
        document.getElementById("kS").value  = "";
        document.getElementById("kS1").value = "";
        document.getElementById("TT").value  = "";
        document.getElementById("TT1").value = "";
        document.getElementById("TG").value  = "";
        document.getElementById("TG1").value = "";
        document.getElementById("XWP").value = "";
        document.getElementById("tWP").value = "";

        const data = new Uint8Array(e.target.result);
        const workbook = XLSX.read(data, { type: "array" });

        const sheet = workbook.Sheets[workbook.SheetNames[0]];
        const rows = XLSX.utils.sheet_to_json(sheet, { header: 1 });

        parseExcelStructure(rows);

        // Kompakte Anzeige + gr√ºn
        fileInfo.innerText = "Geladen: " + file.name;
        fileInfo.classList.add("loaded");

        showFirstThreeRows(rows);
        plotData();
    };

    reader.readAsArrayBuffer(file);
}


/* ---------------------------------------------------------
   Struktur A/B/C erkennen
   und Daten in timeData, xData, yData ablegen
--------------------------------------------------------- */
function parseExcelStructure(rows) {
    timeData = [];
    xData = [];   
    yData = [];   
   
    const first = rows[0];
    const second = rows[1];
    const third = rows[2];

    // Struktur C: 3 Kopfzeilen (Name, Variablen, Einheiten)
    const isC =
        first && typeof first[0] === "string" &&
        second && typeof second[0] === "string" &&
        third;

    if (isC) {
        systemName = first[0];

        varNames.time = second[0] || "Zeit";
        varNames.x    = second[1] || "X";   // Ausgang
        varNames.y    = second[2] || "Y";   // Eingang

        units.time = third[0] || "";
        units.x    = third[1] || "";
        units.y    = third[2] || "";

        for (let i = 3; i < rows.length; i++) {
            const r = rows[i];
            if (!r || r.length < 2) continue;

            timeData.push(r[0]);
            xData.push(r[1]);       // Ausgang
            if (r.length >= 3) yData.push(r[2]);  // Eingang
        }
        return;
    }

    /* ---------------------------------------------------------
       Struktur A/B: 1 Kopfzeile oder keine
       Spalten: Zeit | X | Y?
    --------------------------------------------------------- */
    const hasY = rows[0] && rows[0].length >= 3;

    for (let i = 0; i < rows.length; i++) {
        const r = rows[i];
        if (!r || r.length < 2) continue;

        timeData.push(r[0]);
        xData.push(r[1]);          // Ausgang
        if (hasY) yData.push(r[2]); // Eingang
    }

    systemName = fileName;

    varNames = {
        time: "Zeit",
        x: "X",
        y: hasY ? "Y" : null
    };

    units = {
        time: "",
        x: "",
        y: ""
    };
}

/* ---------------------------------------------------------
   Show first three rows of the raw Excel input in the UI
--------------------------------------------------------- */
function showFirstThreeRows(rows) {
    const preview = document.getElementById("excelPreview");
    if (!preview) return;

    const firstRows = (rows || []).slice(0, 3);
    if (firstRows.length === 0) {
        preview.innerText = "Keine Vorschau verf√ºgbar.";
        return;
    }

    let html = '<table style="border-collapse:collapse; width:100%;">';
    for (let r = 0; r < firstRows.length; r++) {
        const row = firstRows[r] || [];
        html += '<tr>';
        for (let c = 0; c < row.length; c++) {
            const cell = row[c] !== undefined ? String(row[c]) : '';
            html += '<td style="border:1px solid #e6e6e6; padding:6px; font-size:0.85rem;">' + cell + '</td>';
        }
        html += '</tr>';
    }
    html += '</table>';
    preview.innerHTML = html;
}
/* ---------------------------------------------------------
   WP‚ÄëTangente berechnen
--------------------------------------------------------- */
let tangentA = null;
let tangentB = null;

function computeXWP1(xwp, xa, xe, p = 0.05) {
    return xwp + p * (xe - xa);
}

function findNearestPoint(xTarget) {
    let bestIndex = -1;
    let bestDiff = Infinity;

    for (let i = 0; i < xData.length; i++) {
        const diff = Math.abs(xData[i] - xTarget);
        if (diff < bestDiff) {
            bestDiff = diff;
            bestIndex = i;
        }
    }

    if (bestIndex < 0) return null;

    return {
        X: xData[bestIndex],
        t: timeData[bestIndex]
    };
}

function computeTangent(x1, t1, x2, t2) {
    const denom = (t2 - t1);
    if (denom === 0) return null;

    tangentA = (x2 - x1) / denom;
    tangentB = x1 - tangentA * t1;

    return { a: tangentA, b: tangentB };
}
function tFromX(a, b, x) {
    return (x - b) / a;
}


function processWP() {
    const xwp = parseFloat(XWP.value);
    const twp = parseFloat(tWP.value);
    const xa  = parseFloat(XA.value);
    const xe  = parseFloat(XE.value);

    if (![xwp, twp, xa, xe].every(isFinite)) {
        tangentA = null;
        tangentB = null;
        return;
    }

    const xwp1 = computeXWP1(xwp, xa, xe);
    const pt2 = findNearestPoint(xwp1);
    if (!pt2) {
        tangentA = null;
        tangentB = null;
        return;
    }

    computeTangent(xwp, twp, pt2.X, pt2.t);

    // t1 und t2 berechnen
    const t1v = (xa - tangentB) / tangentA;
    const t2v = (xe - tangentB) / tangentA;

    // in UI schreiben
    t1.value = t1v.toFixed(4);
    t2.value = t2v.toFixed(4);
    X1.value = XA.value;
    X2.value = XE.value;
}




/* ---------------------------------------------------------
   Plot-Funktion
--------------------------------------------------------- */
function computeMinMax(arr) {
    if (!arr || arr.length === 0) {
        return { min: null, max: null };
    }
    return {
        min: Math.min(...arr),
        max: Math.max(...arr)
    };
}



function plotData() {
    if (timeData.length === 0) return;

    /* ---------------------------------------------------------
       1) Min/Max berechnen
    --------------------------------------------------------- */
    const timeStats = computeMinMax(timeData);
    const xStats    = computeMinMax(xData);
    const yStats    = computeMinMax(yData);

    const tMin = timeStats.min;
    const tMax = timeStats.max;
    const xMin = xStats.min;
    const xMax = xStats.max;
    const yMin = yStats.min;
    const yMax = yStats.max;

    /* ---------------------------------------------------------
       2) Modellantworten berechnen
    --------------------------------------------------------- */
    const XM = computeModelResponse();
    const XM2 = computeModelResponse2();

    const squaredDifferences = computeSquaredDifferences(xData, XM);
    /* ---------------------------------------------------------
       3) Plot-Traces
    --------------------------------------------------------- */
    const traceX = {
        x: timeData,
        y: xData,
        mode: "lines",
        name: "Messwert X",
        line: { width: 2, color: "blue" },
        xaxis: "x1",
        yaxis: "y1"
    };

    const traceY = {
        x: timeData,
        y: yData,
        mode: "lines",
        name: "Eingang Y",
        line: { width: 2, color: "red" },
        xaxis: "x2",
        yaxis: "y2"
    };

    const traceModel = {
        x: timeData,
        y: XM,
        mode: "lines",
        name: "Modell K√ºpfm√ºller",
        line: { width: 4, color: "red", dash: "dot" },
        xaxis: "x1",
        yaxis: "y1"
    };
    const traceModel2 = {
        x: timeData,
        y: XM2,
        mode: "lines",
        name: "Modell mod.K√ºpfm√ºller",
        line: { width: 3, color: "purple", dash: "dashdot" },
        xaxis: "x1",
        yaxis: "y1"
    };
    

    /* ---------------------------------------------------------
       4) Parameter aus UI lesen
    --------------------------------------------------------- */
    const t0v  = parseFloat(t0.value);
    const t1v = parseFloat(t1.value);
    const tWPv = parseFloat(tWP.value);
    const t2v = parseFloat(t2.value);

    const X1v = parseFloat(X1.value);
    const XWPv = parseFloat(XWP.value);
    const X2v = parseFloat(X2.value);

    const xa = parseFloat(XA.value);
    const xe = parseFloat(XE.value);

    /* ---------------------------------------------------------
       5) Shapes definieren (JETZT ist tMin/tMax verf√ºgbar!)
    --------------------------------------------------------- */
    const shapes = [

        // vertikale Linie t0
        {
            type: "line",
            x0: t0v,
            x1: t0v,
            y0: xe,
            y1: xa,
            xref: "x1",
            yref: "y1",
            line: { color: "orange", width: 2, dash: "dot" }
        },

        // horizontale Linien XA / XE
        {
            type: "line",
            x0: tMin,
            x1: tMax,
            y0: xa,
            y1: xa,
            xref: "x1",
            yref: "y1",
            line: { color: "red", width: 2, dash: "dash" }
        },
        {
            type: "line",
            x0: tMin,
            x1: tMax,
            y0: xe,
            y1: xe,
            xref: "x1",
            yref: "y1",
            line: { color: "red", width: 2, dash: "dash" }
        },

        // horizontale Linien X10 / X50 / X90
        {
            type: "line",
            x0: tMin,
            x1: t1v,
            y0: X1v,
            y1: X1v,
            xref: "x1",
            yref: "y1",
            line: { color: "green", width: 1, dash: "dash" }
        },
        {
            type: "line",
            x0: tMin,
            x1: tWPv,
            y0: XWPv,
            y1: XWPv,
            xref: "x1",
            yref: "y1",
            line: { color: "green", width: 1, dash: "dash" }
        },
        {
            type: "line",
            x0: tMin,
            x1: t2v,
            y0: X2v,
            y1: X2v,
            xref: "x1",
            yref: "y1",
            line: { color: "green", width: 1, dash: "dash" }
        },

        // vertikale Linien t10 / t50 / t90
        {
            type: "line",
            x0: t1v,
            x1: t1v,
            y0: xa,
            y1: X1v,
            xref: "x1",
            yref: "y1",
            line: { color: "green", width: 1, dash: "dash" }
        },
        {
            type: "line",
            x0: tWPv,
            x1: tWPv,
            y0: xa,
            y1: XWPv,
            xref: "x1",
            yref: "y1",
            line: { color: "green", width: 1, dash: "dash" }
        },
        {
            type: "line",
            x0: t2v,
            x1: t2v,
            y0: xa,
            y1: X2v,
            xref: "x1",
            yref: "y1",
            line: { color: "green", width: 1, dash: "dash" }
        }
    ];
/* ---------------------------------------------------------
   5) Werte f√ºr Annotationen vorbereiten
--------------------------------------------------------- */
//xa = parseFloat(XA.value);
//xe = parseFloat(XE.value);


// Standardwerte f√ºr t1v und t2v (falls keine Tangente aktiv)
//let t1v = null;
//let t2v = null;

/* ---------------------------------------------------------
   5b) Tangente einzeichnen, falls vorhanden
--------------------------------------------------------- */
if (tangentA !== null && tangentB !== null) {

    const t1_tan = (xa - tangentB) / tangentA;
    const t2_tan = (xe - tangentB) / tangentA;

    shapes.push({
        type: "line",
        x0: t1_tan,
        y0: xa,
        x1: t2_tan,
        y1: xe,
        xref: "x1",
        yref: "y1",
        line: { color: "black", width: 2 }
    });
}

/* ---------------------------------------------------------
   6) Annotations (nur oberes Diagramm)
--------------------------------------------------------- */
const annotations = [
    {
        x: t0v,
        y: xa,
        xref: "x1",
        yref: "y1",
        text: "t0",
        showarrow: false,
        yshift: -20,
        font: { size: 12, color: "red" }
    },
    {
        x: t1v,
        y: xa,
        xref: "x1",
        yref: "y1",
        text: "t1",
        showarrow: false,
        yshift: -20,
        font: { size: 12, color: "blue" }
    },
    {
        x: tWPv,
        y: xa,
        xref: "x1",
        yref: "y1",
        text: "tWP",
        showarrow: false,
        yshift: -20,
        font: { size: 12, color: "blue" }
    },
    {
        x: t2v,
        y: xa,
        xref: "x1",
        yref: "y1",
        text: "t2",
        showarrow: false,
        yshift: -20,
        font: { size: 12, color: "blue" }
    }
];
    
   /* ---------------------------------------------------------
   7) Plot erzeugen (Subplots)
--------------------------------------------------------- */
const showDiffEl = document.getElementById("showDiff");
const showDiff   = showDiffEl ? showDiffEl.checked : false;

// Hilfsfunktion kann auch au√üerhalb von plotData stehen
function computeSquaredDifferences(meas, model) {
    const diffs = [];
    const n = Math.min(meas.length, model.length);
    for (let i = 0; i < n; i++) {
        const d = meas[i] - model[i];
        diffs.push(d * d);
    }
    return diffs;
}

let traces;
let y2Title;

if (showDiff) {
    const diffSquared = computeSquaredDifferences(xData, XM);
    const diffSquared2 = computeSquaredDifferences(xData, XM2);
    const traceDiff = {
    x: timeData,
    y: diffSquared,
    mode: "lines",
    name: "Abweichung¬≤ Modell 1",
    xaxis: "x2",
    yaxis: "y2",
    line: { color: "red", width: 2 }
};

const traceDiff2 = {
    x: timeData,
    y: diffSquared2,
    mode: "lines",
    name: "Abweichung¬≤ Modell 2",
    xaxis: "x2",
    yaxis: "y2",
    line: { color: "purple", width: 2, dash: "dot" }
};


    // oben: X + Modelle, unten: Abweichung¬≤
    traces = [traceX, traceModel, traceModel2, traceDiff, traceDiff2];

    y2Title = "Œîx¬≤(t)";
} else {
    // exakt dein alter Zustand: oben X + Modelle, unten Y
    traces  = [traceX, traceModel, traceModel2, traceY];
    y2Title = "y(t)";
}

Plotly.newPlot("plotArea", traces, {
    title: {
        text: loadedFilename ? ("Datei: " + loadedFilename) : "PT1TT ‚Äì Zeitverl√§ufe",
        y: 0.95,
        pad: { t: 10 }
    },
    grid: {
        rows: 2,
        columns: 1,
        roworder: "top to bottom",
        heights: [0.67, 0.33],
        pattern: "independent",
        ygap: 0.02
    },
    xaxis:  { title: "Zeit" },
    yaxis:  { title: "x(t)" },
    xaxis2: { title: "Zeit" },
    yaxis2: { title: y2Title },
    shapes: shapes,
    annotations: annotations,
    margin: { t: 60, r: 20, b: 40, l: 50 }
});
}




/* ---------------------------------------------------------
   Event‚ÄëListener
--------------------------------------------------------- */
XA.addEventListener("input", () => { 
    updateDX(); 
    processWP(); 
    plotData(); 
});

XE.addEventListener("input", () => { 
    updateDX(); 
    processWP(); 
    plotData(); 
});


YA.addEventListener("input", () => { updateDY(); plotData(); });
YE.addEventListener("input", () => { updateDY(); plotData(); });


t0.addEventListener("input", () => { updateTimeOrder(); plotData(); });
//t1.addEventListener("input", () => { updateTimeOrder(); plotData(); });
tWP.addEventListener("input", () => { 
    updateTimeOrder(); 
    processWP(); 
    plotData(); 
});
XWP.addEventListener("input", () => { 
    updateXWPRange();
    processWP(); 
    plotData(); 
});
X1.addEventListener("input", updateXWPRange);
X2.addEventListener("input", updateXWPRange);


//t2.addEventListener("input", () => { updateTimeOrder(); plotData(); });
showDiff.addEventListener("change", plotData);

/* ---------------------------------------------------------
   Initiale Berechnung + Plot
--------------------------------------------------------- */
updateDX();
updateDY();
updateXvalues();
updateTimeOrder();
updateDerivedValues();
plotData();

</script>



</body>
</html>
